\chapter{Wymogi funkcjonalne aplikacji}
\label{chapter:app_functional_requirements}

	\section{Głowna funkcjonalność biznesowa}
		Analiza istniejących rozwiązań pozwoliła na ustalenia, że minimalna funkcjonalność programu realizujące wsparcie dla przedsiębiorstwa prowadzącego warsztat samochodowy nie powinna się ograniczać jedynie do wspomagania procesów: wymiany płynów eksploatacyjnych czy też napraw. Prowadzenia ewidencji klientów, pojazdów oraz ich wzajemnych powiązań przekłada się na efektywność pracy, dając jednocześnie dostęp do danych historycznych. Jest to szczególnie użyteczne w przypadku okresowych wymian oleju silnikowego czy też płynu chłodniczego, kiedy można odwołać się do danych z poprzedniej wizyty danego klienta i uzupełnić ewentualne braki magazynowe. Funkcjonalność programu dla warsztatów samochodowych to między innymi pomoc dla następujących obszarów pracy warsztatu samochodowego:
		\begin{enumerate}
			\item \textbf{klienci}:
			\begin{enumerate}
				\item ewidencja, możliwość rejestracji nowych klientów,
				\item powiązania z samochodem
			\end{enumerate}
			\item \textbf{samochody}:
			\begin{enumerate}
				\item historia własności,
				\item historia wizyt
			\end{enumerate}
			\item \textbf{zlecenia serwisowe}:
			\begin{enumerate}
				\item wprowadzenia nowych zleceń,
				\item edytowania zleceń które nie zostały jeszcze zamknięte (nie minął termin ich wykonania)
				\item tworzenie listy zadań dla każdego zlecenia,
				\item usuwania zleceń,
				\item powiązania zlecenie - samochód - klient
			\end{enumerate}
			\item \textbf{powiadomienia} - wewnętrzny system wiadomości:
			\begin{enumerate}
				\item powiadomienia o nowym zleceniu,
				\item powiadomienie o zbliżającym się zleceniu,
				\item powiadomienia o zmianie stanu zlecenia
			\end{enumerate}
		\end{enumerate}
	
	\section{Architektura aplikacji}
		Aplikacja została zrealizowana z architekturze trójwarstwowej według modelu MVC\footnote{Model-View-Controller} z uwagi na rozmiar aplikacji oraz mnogość funkcji implementowanych przez program. Niejednokrotnie, z uwagi na szczegółowość modelu danych, wygodniejsze okazuje się przetwarzanie danych na poziomie serwera, do dodatkowo przemawia za wybraną architekturą. Dzięki warstwie kontrolerów można uzyskać wydajny sposób na przekazywanie informacji na linii klient-serwer, wykonanie operacji zgodnych z jej treścią i odesłanie wyniku. Skomplikowana logika biznesowa, gdzie na poszczególne wydarzenia należy reagować inaczej zależnie od parametrów jest powodem dla którego praca z danymi na poziomie klienta mogłaby się okazać niemożliwa lub trudniejsza z uwagi na konieczność pobrania dodatkowych danych z serwera, czyli wykonania następnych zapytań. Złożone przypadki można wydajniej i dokładniej obsłużyć mając dostęp do pełnego modelu danych oraz interfejsów dla operacji bazodanowych, niż pisać skomplikowany kod JavaScript. Niemniej logika biznesowa nie jest jedynym powodem dla którego wybrana została architektura MVC. Zawiłość po stronie serwera jest odzwierciedlona po stronie interfejsu użytkownika, który musi odwzorować związki między obiektami modelu danych oraz zaprezentować możliwe do wykonania akcja.  
	\section{Minimalizacja własnego kodu}
		W momencie projektowanie nowej aplikacji bardzo często początki pracy to tworzenia kodu potrzebnego do wykonywania powtarzalnych operacji takich jak zapis i odczyt z bazy danych, reagowanie na zdarzenia interfejsu użytkownika czy też walidacja danych wejściowych. Nie jest to problematyczne dla małych projektów. Niestety, wraz ze wzrostem ilości linii kodu, złożoności klas czy też skomplikowania logiki biznesowej, okazuje się, że początkowo proste moduły rozrastają się w niekontrolowany sposób. Odwrotnie proporcjonalnie zmniejsza się możliwość na utrzymaniu i rozbudowę kodu aplikacji. Dodatkowe problemy pojawią się wraz z wprowadzeniem do programu cache'owania, konwertowanie danych między niekompatybilnymi typami, transakcji operacji bazodanowych. W tym momencie wzrost ogólnego skomplikowania kodu nie będącego częścią właściwej funkcjonalności jest jedynie jednym z problemów. Rosnąca zależność klas miedzy sobą, głębokości drzewa dziedziczenia dla klas oraz konieczność objęcia wspomnianymi elementami kolejnych obszarów programu przekłada się na zmniejszenie jakości kodu. Z tego powodu głównym założeniem części praktycznej jest wykorzystanie możliwie jak najwięcej funkcji oferowanych przez wybrane biblioteki do realizacji powtarzalnych operacji:
		\begin{itemize}
			\item generowanie zapytań SQL,
			\item operacje zapisu i odczytu z/do bazy danych,
			\item obsługa transakcji bazodanowych,
			\item walidacja danych pod kątem logiki biznesowej,
			\item konwertowanie danych miedzy niekompatybilnymi typami,
			\item efektywne reagowania na zdarzanie interfejsu użytkownika,
			\item minimalizacja ilości kodu linii JSP, skupienie się na właściwych stronach dostarczających interfejs,
			\item zmniejszenia kohezji między klasami,
			\item zmniejszenie głębokości drzew dziedziczenia
		\end{itemize}
		Podniesienie jakości kodu oraz możliwości jego późniejszego utrzymaniu oraz rozszerzenia o nowe funkcjonalności stanowi o sile każdej aplikacji, z tego powodu był to główny wyznacznik przy projektowaniu i implementacji części praktycznej pracy dyplomowej.
	\subsection{Generyczne moduły}
		Generyczne moduły są odpowiedzią na podniesienie optymalności oraz możliwości późniejszego rozszerzenia aplikacji. Koszt zaprojektowania niezależnych elementów programu realizujących pewne zadania jest akceptowalny z uwagi na następujące korzyści. Istniejący moduł przeznaczony do realizowania pewnego zadania, gdzie dane wejściowe to obiekty modelu danych, można następnie użyć dla nowych obiektów tego typu bez konieczności modyfikacji, lub nieznacznej zmiany istniejącej funkcjonalności. 
	\section{Przewodniki - kreatory nowych obiektów}
		Biorąc pod uwagę funkcjonalność w zakresie realizacji celów biznesowych jednym z nadrzędnych celów jest dostarczenie możliwości tworzenia nowych obiektów modelu danych. Z uwagi na stopień skomplikowania modelu, jego wzajemnych relacji pojedyncze formularze to zły wybór. Głównym powodem tego powodem jest ilość danych potrzebnych do wprowadzenia, gdzie umieszczenie ich na wspólnej stronie mogłoby być kłopotliwe dla osoby używającej aplikacji. Podzielenia całego procesu na sekwencję kroków według zasady wprowadzenia logicznie ze sobą związanych danych odpowiadających pewnym cechą danego obiektu modelu danych pozwala na reagowania, w kolejnych krokach przewodnika, na dane wejściowe z danego i poprzednich kroków. Ponadto przetwarzanie danych wprowadzonych w danym kroku przewodnika odbywa się na serwerze, dzięki czemu istnieje dostęp do istniejących mechanizmów walidacji oraz innych danych na podstawie których możliwa jest wstępna weryfikacja obiektu na poziomie powiązań z innymi obiektami. Tym samym, możliwość wprowadzenia danych niepoprawnych, których ewentualna walidacja, polegająca na sprawdzeniu, na przykład, długości łańcuchów znakowych, mogłaby nie przechwycić, zostaje zmniejszona.
	\section{Terminarz - organizacja wizyt}
		Z uwagi na specyfikę aplikacji, jako narzędzia służącego przede wszystkim organizacji pracy warsztatu, terminarz jest funkcją której nie można pominąć. Intuicyjne używanie kalendarza jako terminarza, gdzie zapisywane są poszczególne spotkania, wizyty czy też zadania do wykonania, gdzie ważna jest data jest przydatne tutaj. Terminarz przygotowany w części praktycznej jest posiadać będzie 3 tryby widoku: \textbf{dzienny}, \textbf{miesięczny}, \textbf{tygodniowy}. Z uwagi na częstotliwość wizyt, ilość mechaników a co ważniejsze ilość klientów, a tym samym ich samochodów, 3 tryby pracy z terminarzem są koniecznością. Z poziomu kalendarza będzie można tworzyć nowe wizyty, zmieniać ich godziny lub je edytować. 

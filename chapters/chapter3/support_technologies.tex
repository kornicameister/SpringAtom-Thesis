Mimo, że \textbf{Spring} jest doskonałym fundamentem dla aplikacji internetowej, nie dostarcza on bezpośredniego wsparcia, ani też nie narzuca, w jaki sposób aplikacja ma się komunikować z bazą danych, czy też z jakiego silnika bazodanowego ma korzystać. Nie istnieje też żaden komponent, który zarządzałby połączeniem z samą bazą, zajmował się kolejkowaniem żądań i rozdzielaniem zasobów. Zarówno to, że \textbf{Spring} jest wysoce konfigurowalnym rozwiązaniem oraz, że jest niezwykle popularny, nie ma żadnego problemu z wyborem technologii, które wspierały by pewną funkcjonalność czy też całkowicie zastępowały tę, którą wybrany szkielet programistyczny oferuje.  

\subsection{Hibernate - Object Relational Mapping}
\label{tech:hibernate}
	\textbf{Hibernate} to otwarto źródłowy projekt, zaprojektowany dla zarządzania danymi trwałymi w języku Java. Nie jest to problem nowy, ani też łatwy do rozwiązania. Potwierdza to szeroka gama rozwiązań podobnych do \textbf{Hibernate}: \href{http://www.jooq.org/}{\textbf{jOOQ}}, \href{http://blog.mybatis.org/}{\textbf{MyBatis}}, \href{http://www.simpleorm.org/}{\textbf{SimpleORM}}. Wspólną ich cechą jest efektywne mapowanie relacji i tabel znajdujących się w bazie danych, na zrozumiały i łatwy w utrzymaniu model danych. Różnice natomiast to, to jak szczegółowo można zamodelować kompleksowy model danych, jak i ile różnych silników bazodanowych jest wspierane oraz jak rozwiązany jest problem definiowania nowych typów danych. 
	
	Wybrany silnik \textbf{ORM} rozwiązuje powyższe problemy odpowiadając na pytania: co jeśli baza danych MySQL zostanie zamieniona na bazę danych Oracle, jak efektywnie zaprezentować pojedynczą krotką jako obiekt, czy też zrealizować koncepcję zaprezentowania pojedynczych atrybutów takiej krotki, jako liczb, łańcuchów znakowych, typu wyliczeniowego czy tez innych obiektów. Ostatni z problemów znany jest pod angielską nazwą \textit{object/relational paradigm mismatch}. 
	
	Dla złożonej tabeli, posiadającej kilkanaście atrybutów oraz powiązań z innymi, bardzo łatwo wyodrębnić takie, które, z punktu widzenia programowania obiektowego, najlepiej przedstawić jako w postaci odrębnej klasy. Bardzo dobrym przykładem jest tutaj adres. Na adres składają się takie informacje jak ulica, numer domu i/lub mieszkania, kraj oraz numer pocztowy. Nawet na poziomie bazy danych, zalecane jest, aby te informacje przechowywane były w relacji jeden do jednego, pojedynczy atrybut - pojedyncza kolumna. Zarówno przypadek, kiedy adres jest oddzielną tabelą, czy też kiedy jest to grupa atrybutów innej tabeli, jest obsługiwany przez elastyczny model mapowania \textbf{Hibernate'a}. To co wyróżnia to rozwiązanie, a co przykłada się na jakość kodu obiektowego, to spełnienie zasady pojedynczego celu wybranej klasy. Adres, zdefiniowany jako samodzielny artefakt, staje się złożonym typem danych, którego można użyć w więcej niż jednym kontekście.
	Alternatywą dla takiego rozwiązania problemu niespójności danych są definiowane przez użytkownika, na poziomie bazy danych, własne typy. Niemniej jest to funkcjonalność, której implementacja jest unikatowa dla poszczególnych systemów bazodanowych. Skutkiem tego jest brak prostego sposobu na przeniesienie takiego typu danych w przypadku migracji do innej bazy danych. Nie jest to jednak kwestia dyskusyjna, trudna do zrealizowania dla \textbf{Hibernate}. Wsparcie dla wielu baz danych, daje możliwość tworzenie kodu obiektowego, łatwiejszego w przenoszeniu, mniej podatnego na zmiany, w przypadku migracji do innego silnika bazodanowego. Ostatecznie, podobnie jak wybrany szkielet aplikacji, nie wymusza on korzystania ze wszelkich możliwych funkcjonalności. Z drugiej strony dodanie kolejnego modułu, takiego jak walidacja danych na poziomie modelu obiektowego, jest bardzo prosta i sprowadza się do dodania nowej biblioteki do aplikacji, a następnie opatrzenia odpowiednimi adnotacjami wybranych atrybutów. Adnotacje określają ograniczenie, takie jak zakres liczb dla danych numerycznych lub długość łańcuchów znakowych. 
	
\subsection{QueryDSL}
\label{tech:queryDSL}
	Wykorzystanie \textbf{Spring Data JPA} (\ref{app:spring_data}) w znaczący sposób uprościło warstwę dostępu do danych. Niemniej w dalszym ciągu nie istniała możliwość budowania bardziej skomplikowanych zapytań, w których można by pobrać dane po więcej niż tylko kluczu głównym. Spośród przeanalizowanych rozwiązań, zapewniających tę funkcjonalność, takich jak \textbf{JPA Criteria}, \textbf{Hibernate Criteria} i \textbf{QueryDSL}, wybrany został ostatni z wymienionych projektów. Najważniejszym czynnikiem, pod kątem którego ocenione zostały rozwiązania, było generowanie silnie typizowanych zapytań. Niestety \textbf{Hibernate Criteria}, pozwalając tworzyć zapytania zorientowane na konkretną klasę modelu danych, jednocześnie nie dawał możliwości uzyskania wyniku zgodnego z oczekiwanym. W dalszym ciągu wymaganą operacją było rzutowanie na pożądany typ danych. Z drugiej strony \textbf{JPA Criteria}, zostało odrzucone z uwagi na problematyczne tworzenie zapytania. Koncepcja oparta o tworzenie klas, których zadaniem było zwracanie jego specyfikacji, wciąż wymagała napisania od kilkunastu do kilkudziesięciu linii kodu. 
	\begin{code}
		\inputminted[
			linenos=true,
			firstline=212,
			lastline=244,
			fontfamily=monospace,
			obeytabs=true,
			samepage=true,
			fontsize=\scriptsize
		]{java}{../SpringAtom_thesis/src/main/java/org/agatom/springatom/server/service/domain/impl/SCarServiceImpl.java}
		\caption[Specyfikacja zapytania w rozumieniu biblioteki \textbf{QueryDSL}]{
			Specyfikacja zapytania w rozumieniu biblioteki \textbf{QueryDSL}, źródło: opracowanie własne	
		}
		\label{app:query_dsl_code}
	\end{code}
	\textbf{QueryDSL} przerzuca odpowiedzialność za utworzenie takiej specyfikacja na siebie. W tym przypadku, to jak zapytanie będzie wyglądać, jakie atrybuty danego modelu, czyli kolumny tabeli, zostaną uwzględnione, kontrolowane jest przez odpowiednie użycie meta modelu danej klasy modelu danych. Wspomniany meta model to klasa języka Java. Wynikająca z tego korzyść polega na tym, że wraz z nim, można tworzyć zapytania korzystając z uzupełnia składni, oferowanego przez praktycznie wszystkie środowiska programistyczne. Inną ważną zaletą są pola klas meta modelu. Odpowiadają one atrybutom biznesowego modelu danych, dzięki czemu nie ma konieczności pamiętania o ich wewnętrznych nazwach\footnote{Wewnętrzna nazwa - nazwa kolumn odpowiadającej danemu atrybutowi klasy modelu danych}, jakby to miało miejsce podczas pisania identycznego zapytania opartego o łączenie łańcuchów znakowych, czy też z wykorzystaniem \textbf{Hibernate Criteria} lub \textbf{JPA Criteria}. 
	Listing \ref{app:query_dsl_code} pokazuje tworzenie zapytania, gdzie pobrane obiekty klasy \textbf{SUser} muszą posiadać dwie konkretne role, ich nazwa użytkownika musi różnić się od \textbf{"SYSTEM"}, konto nie może być zablokowane oraz nieważne. Podczas tworzenia takiego zapytania szczególnie istotne jest to, że oprócz silnego typizowania wyniku, takie wsparcie jest obecne również podczas definiowania specyfikacji. Przykładowo, nie możliwe jest podanie liczby jako argumentu dla atrybuty \textbf{accountNotLocked}, który w klasie \textbf{SUser}, a tym samym jego meta modelu, zdefiniowany został jako zmienna logiczna. 

\subsection{c3p0}
\label{tech:c3p0}
	\textbf{c3p0} jest łatwą do użycia biblioteką zaprojektowaną dla \textbf{Java}, której głównym zadaniem jest realizacja postulatów zdefiniowanych przez specyfikacje \textbf{JDBC 3}. Dzięki powyższej bibliotece można w łatwy sposób zdefiniować \textbf{n} - połączeń z bazą danych, gdzie kolejne z nich będą wykorzystywane jeśli kolejka żądań do innych będzie już pełna. Także elementy takie jak zarządzanie zasobami, zajmowanie oraz zwalnianie, są obsługiwane przez \textbf{c3p0}. Dzięki wsparciu dla szkieletu aplikacji \textbf{Spring} konfiguracja okazuje się trywialna i polega na zadeklarowaniu odpowiedniego obiektu w pliku konfiguracyjnym XML lub adnotacji na poziomie języka Java \cite{c3p0}.
	
\subsection{Ehcache}
	\textbf{Ehcache} jest biblioteką dostarczającą funkcjonalność pamięci podręcznej dla aplikacji Java oraz Java Enterprise. Główną zaletą posiadania takiego rozwiązania jest odciążanie bazy danych, ponieważ część zapytań oraz ich wyników zapisana jest w pamięci lub w systemie plików. Użyteczność tej biblioteki potwierdza zasada znana, jako \textbf{zasada Pareto}, czyli stosunku 80:20. Jeśli weźmiemy pod uwagę 20\% obiektów (np. rekordów z bazy danych), które używane są przez 80\% czasu działania aplikacji to używając pamięci podręcznych możemy poprawić wydajność aplikacji o koszt uzyskania 20\% obiektów.
	
	W ogólnym zarysie idea działania pamięci podręcznej opiera się na tablicy asocjacyjnej, gdzie każdemu z unikatowych kluczy odpowiada pewna wartość. Podczas umieszczania obiektu do pamięci obliczana jest unikatowa wartość klucza dla tego obiektu. Samą pamięć można opisać jako miejsce, w którym czasowo przechowuje się obiekty pochodzące z bazy danych lub wyniki długotrwałych obliczeń. Podczas próby pobrania elementu z cache można mówić o pojęciu \textbf{hit} - element dla danego klucza zostaje znaleziony oraz o pojęciu \textbf{miss}, kiedy element o danym kluczu nie istnieje w pamięci podręcznej \cite{ehcache_documentation_ref}.
		
\subsection{Apache Tiles}
\label{tech:tiles}
	\textbf{Apache Tiles} to biblioteka umożliwiająca dekompozycję widoku aplikacji na wiele niezwiązanych ze sobą bezpośrednio elementów - płytek \footnote{Z angielskiego \textit{tiles} może oznaczać płytkę, w kontekście technologii \textbf{Apache Tiles} należy rozumieć to wyrażenie, jako element, który można wykorzystać w dowolnym szablonie}. Płytki można dowolnie łączyć w konkretne widoki, definiując je na poziomie plików XML. Główną zaletą korzystanie ze wzorca kompozycji jest wyeliminowanie powielania się elementów stron i zastąpienie ich szablonami gotowymi do użycia w dowolnym miejscu. Narzut obliczeniowy potrzebny na połączenie kilkunastu płytek w gotowy szablon jest akceptowalny z uwagi na obniżenie złożoności pojedynczych plików JSP oraz wyeliminowanie problemu duplikowanego kodu JSP. 
	Dodatkową zaletą użycia tej biblioteki było gotowe wsparcie dla modułu Spring’a – Spring Webflow \ref{tech:spring_web_flow}, gdzie jedną z preferowanych technologii widoku jest właśnie Apache Tiles, a także możliwość prostszego wsparcia dla \textbf{partial rendering}\footnote{Partial rendering należy rozumieć, jako usunięcie konieczności przeładowania całej strony internetowej, a jedynie jej konkretnej części.} stron, gdzie podczas przechodzenia do innego adresu w rzeczywistości zamiast ładować całość strony wraz ze wszystkimi plikami \textit{CSS} oraz \textit{JavaScript}, ładuje się jedynie treść danej strony. 
	
\subsection{Jasper Reports/Dynamic Jasper}
\label{tech:jasperReports}
	\textbf{Jasper Reports} to kompleksowe rozwiązanie dla języka \textbf{Java} wspierające tworzenie oraz generowanie raportów biznesowych dla różnorodnych formatów wyjściowych: \textbf{PDF}, \textbf{XLS}, \textbf{CSV}. Jego główną zaletą jest pojedynczy format przechowywania raportu oraz mnogość formatów reprezentacji, a także ogromna ilość  narzędzi oraz bibliotek wspierających tworzenie i modyfikacje raportów. Z drugiej strony wiele tych narzędzi jest aplikacjami uruchamianymi na komputerach użytkowników, a nie zaprojektowanych do wykorzystania w aplikacji internetowej. Z tego powodu właściwą biblioteką, która została użyta celem utworzenia raportu jest \textbf{Dynamic Jasper}. Działając po stronie serwera oraz bazując na danych wejściowych uzyskanych od użytkownika pozwala na kompilację do pliku \textit{*.jasper}. Możliwe jest ustalenie takich właściwości jak nagłówki, styl, ilość kolumn oraz typ danych w nich przechowywanych.

\subsection{Dandelion Datatables}
\label{tech:dandelion}
	\textbf{Dandelion Datatables} jest biblioteką zaprojektowaną dla języka \textbf{Java}, której zadaniem jest wsparcie dla tworzenia tabel korzystając z użyciem tagów JSP. Instrukcje dostarczane tą drogą uruchamiają proces generowania kodu JavaScript dla wtyczki \textbf{jQuery} - \textbf{DataTables}. Nie ma konieczności bezpośredniego pisania kodu JS co pozwala na budowania responsywnych tabel bez znajomości języka JavaScript. \textbf{Dandelion Datables} pozwala na bezproblemowe sortowanie, filtrowanie oraz eksportowanie danych. 
	
\subsection{FullCalendar}
\label{tech:fullCalendar}
	\textbf{Full Calendar} jest graficznym komponentem zaprojektowanym na podstawie biblioteki \textbf{jQuery}. Jest on odpowiedzialny za wyświetlenie kalendarza, działającego w formie terminarza. 3 różne tryby widoku: dzienny, tygodniowy i miesięczny dają możliwość dostosowania terminarza do aktualnych potrzeb. Komponent pobiera zdarzenia korzystając z zapytań Ajax. Sam komponent można dostosować do dowolnego źródła danych \cite{fullCalendar}.